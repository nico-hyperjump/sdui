/** THIS FILE IS AUTOMATICALLY GENERATED BY ROUTE-ACTION-GEN **/
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
"use client";

import type {
  requestValidator,
  responseValidator,
} from "../../../../../pages/api/posts/[postId]/route.delete.config";
import { useCallback, useMemo, useState } from "react";
import { z } from "zod";

/**
 * A custom hook to use the route delete that executes the handler function in the `route.delete.config.ts` file.
 *
 * @returns An object with the `data`, `error`, `isLoading`, and `fetchData` properties.
 */
export const useRouteDelete = () => {
  const [data, setData] = useState<z.infer<typeof responseValidator> | null>(
    null,
  );
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const fetchData = useCallback(
    async (
      inputData: {
        params: z.infer<NonNullable<typeof requestValidator.params>>;
        options?: { abortController?: AbortController; timeoutMs?: number };
      },
      isCleanedUp?: () => boolean,
    ) => {
      setIsLoading(true);
      setError(null);
      setData(null);

      const { params, options } = inputData;
      const { abortController = new AbortController(), timeoutMs = 10_000 } =
        options ?? {};
      const { postId } = params;

      const combinedSignal = AbortSignal.any([
        abortController?.signal,
        AbortSignal.timeout(timeoutMs),
      ]);

      try {
        const response = await fetch(`/api/posts/${postId}`, {
          signal: combinedSignal,
          method: "delete",
        });

        if (!response.ok) {
          const error = await response.json();
          setError(new Error(error.message));
          return;
        }

        if (!isCleanedUp?.()) {
          const responseData = await response.json();
          setData(responseData);
        }
      } catch (error) {
        if (!isCleanedUp?.()) {
          setError(error as Error);
        }
      } finally {
        setIsLoading(false);
      }
    },
    [],
  );

  return useMemo(
    () => ({ data, error, isLoading, fetchData }),
    [data, error, isLoading, fetchData],
  );
};
