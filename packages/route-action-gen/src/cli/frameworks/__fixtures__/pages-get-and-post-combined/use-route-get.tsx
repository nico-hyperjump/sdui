/** THIS FILE IS AUTOMATICALLY GENERATED BY ROUTE-ACTION-GEN **/
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
"use client";

import type {
  requestValidator,
  responseValidator,
} from "../../../../../pages/api/posts/[postId]/route.get.config";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { z } from "zod";

/**
 * A custom hook to use the route get that executes the handler function in the `route.get.config.ts` file.
 *
 * @param input - The input object with the params and search params.
 * @returns An object with the `data`, `error`, `isLoading`, `cancel`, `refetch`, and `lastFetchedAt` properties.
 */
export const useRouteGet = (input: {
  params: z.infer<NonNullable<typeof requestValidator.params>>;
}) => {
  const [data, setData] = useState<z.infer<typeof responseValidator> | null>(
    null,
  );
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setLoading] = useState(false);
  const abortControllerRef = useRef<AbortController | null>(null);
  const [lastFetchedAt, setLastFetchedAt] = useState<number | null>(null);
  const isMountedRef = useRef(false);

  // Initialize lastFetchedAt on mount to prevent hydration errors
  // This ensures the initial value is consistent between server and client
  useEffect(() => {
    if (!isMountedRef.current) {
      isMountedRef.current = true;
      setLastFetchedAt(Date.now());
    }
  }, []);

  useEffect(() => {
    // Skip fetch if lastFetchedAt hasn't been initialized yet
    if (lastFetchedAt === null) {
      return;
    }

    let isCleanedUp = false;
    const thisLastFetchedAt = lastFetchedAt;

    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    const fetchData = async () => {
      // reset the states
      setLoading(true);
      setError(null);
      setData(null);

      const combinedSignal = AbortSignal.any([
        abortController.signal,
        AbortSignal.timeout(1_000 * 5), // 5 seconds timeout
      ]);
      const url = window.location.protocol + "//" + window.location.host;
      const fetchURL = `${url}/api/posts/${input.params.postId}`;
      try {
        const response = await fetch(fetchURL, {
          signal: combinedSignal,
        });

        if (!response.ok) {
          if (!isCleanedUp) {
            const errorBody = await response.json();
            setError(errorBody.message ?? response.statusText);
            setLoading(false);
          }
          return;
        }

        if (!isCleanedUp && lastFetchedAt === thisLastFetchedAt) {
          const responseData = await response.json();
          setData(responseData);
          setLoading(false);
          setError(null);
        }
      } catch (error: unknown) {
        if (!isCleanedUp) {
          setLoading(false);

          if (error instanceof Error && error.name === "TimeoutError") {
            setError("Timeout: It took more than 5 seconds to get the result!");
          } else if (error instanceof Error && error.name === "AbortError") {
            setError(`Fetch canceled by user`);
          } else {
            setError(
              error instanceof Error
                ? error.message
                : "An unknown error occurred",
            );
          }
        }
      }
    };

    fetchData();

    return () => {
      isCleanedUp = true;
      abortController.abort();
      abortControllerRef.current = null;
    };
  }, [input.params.postId, lastFetchedAt]);

  const cancel = useCallback(() => {
    abortControllerRef.current?.abort();
  }, []);

  const refetch = useCallback(() => {
    // abort the current fetch
    abortControllerRef.current?.abort();
    // set the last fetched at to the current time
    setLastFetchedAt(Date.now());
  }, []);

  return useMemo(
    () => ({ data, error, isLoading, cancel, refetch, lastFetchedAt }),
    [data, error, isLoading, cancel, refetch, lastFetchedAt],
  );
};
