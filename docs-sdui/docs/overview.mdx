---
title: Overview
description: System overview, problem statement, and the SDUI solution
icon: BookOpen
---

import { Callout } from "fumadocs-ui/components/callout";

## Problem Statement

Significant challenges managing multiple mobile apps across multiple brands, for example, 3 brands x 2 platforms:

- **6 separate codebases** with duplicated functionality across brands
- **App store dependency** causing 1–2 week delays for simple UI updates
- **High maintenance costs** from multiple development teams
- **Inconsistent user experiences** across brands
- **Slow time-to-market** for new features and promotions

## The SDUI Solution

The Server-Driven UI (SDUI) Platform solves these problems with a hybrid architecture combining:

1. **Shared Codebase** — A single React Native + Expo monorepo that builds all 6 apps (3 brands x iOS/Android)
2. **Server-Driven Layouts** — Screen structures defined as JSON schemas on the server, rendered dynamically by the mobile app
3. **CMS for Business Users** — A web admin panel where non-technical users can modify content, toggle features, and run A/B tests
4. **Over-The-Air Updates** — Code changes pushed to devices without app store submissions via Expo Updates

## How It Works

The platform works on a simple principle: **the server decides what the app looks like, and the app knows how to render it**.

<Mermaid
  chart={`flowchart LR
    CMS[CMS Admin Panel] -->|Edit screens, flags, themes| API[SDUI Server]
    API -->|JSON UI Schema| SDK[Mobile SDK]
    SDK -->|Renders components| App[Branded Mobile App]
    DB[(SQLite Database)] --> API
    Sources[Data Source Apps] -->|Dynamic data| API
`}
/>

### The UI Schema

Instead of hardcoding screen layouts, each screen is described as a **JSON document** (UI schema) that specifies:

- **Which components** to display (hero banners, cards, grids, etc. — 54 component types)
- **Component properties** (text, images, colors, actions)
- **Layout hierarchy** (nesting and ordering)
- **Actions** to trigger (navigation, webviews, custom handlers)
- **Overlays** to present (bottom sheets, modals triggered by actions)
- **Data sources** to fetch (marketing offers, account info, resolved server-side via template expressions)
- **Conditions** for when to show content (brand, segment, feature flags)
- **Analytics metadata** for tracking impressions and clicks

### Data Sources

Screens can declare **data sources** that are resolved server-side before the response reaches the client:

- **Marketing offers** — Promotions, bundles, and deals served from a dedicated marketing data source (port 3002)
- **Account information** — User balances, plan details, and profile data from an account data source (port 3003)

Component props use `{{expression}}` template syntax (e.g., `"Hi {{account.name}}"`), and a **repeat directive** can generate components dynamically from data arrays (e.g., one product card per offer). The mobile SDK receives fully resolved screens — no template logic on the client.

### Brand Differentiation

All brands share the same 54-component library but each has its own:

| Brand   | Name    | Theme         | Target Audience                   |
| ------- | ------- | ------------- | --------------------------------- |
| Brand A | Premium | Navy & Gold   | Business, high-value postpaid     |
| Brand B | Youth   | Purple & Lime | Young adults, prepaid, data-heavy |
| Brand C | Value   | Orange & Teal | Price-conscious families          |
| Demo    | Demo    | Default       | Development and testing           |

Themes are stored in the database and applied at runtime — changing a brand's colors, typography, or assets requires no code changes.

### Feature Flags

Features can be toggled independently per brand with rollout percentage control:

- **eSIM Support** — enabled for Brand A only
- **Chat Support** — gradually rolling out to 50% of Brand B users
- **Biometric Login** — enabled for all brands

### A/B Testing

The platform supports deterministic A/B testing where:

- Tests target a specific screen + brand combination
- Users are assigned to variants using a hash of their user ID and test ID (deterministic)
- Each variant can completely replace the screen's component tree
- Test results are tracked via the built-in analytics system

### Personalization

Content is personalized based on user segments:

- **Prepaid** users see data bundles and top-up offers
- **Postpaid** users see device upgrades and family plans
- **Business** users see enterprise plans and multi-line deals

The server resolves the correct screen variant based on the brand, segment, and active A/B tests for each request.

## Technology Stack

| Layer        | Technology              | Why                                                                               |
| ------------ | ----------------------- | --------------------------------------------------------------------------------- |
| Mobile       | React Native + Expo     | Cross-platform, OTA built-in, fast development                                    |
| Server       | Hono (Node.js)          | Lightweight, TypeScript-native, fast                                              |
| Database     | SQLite (Prisma)         | File-based, no infrastructure, sufficient for PoC, can be swapped with PostgreSQL |
| CMS          | React + Vite + Tailwind | Fast build, modern UI, familiar stack                                             |
| OTA          | Expo Updates            | Built into Expo, zero additional setup                                            |
| Validation   | Zod                     | Runtime type safety for schemas and API contracts                                 |
| Data Sources | Hono microservices      | Standalone apps with own databases for marketing offers and account data          |
| Monorepo     | pnpm + Turborepo        | Fast, efficient dependency management and build orchestration                     |

## Success Criteria

The PoC demonstrates:

1. Four branded apps (3 brands + demo) sharing over 80% of codebase
2. UI updates deployed in under 5 minutes without app store submission
3. Brand-specific theming from shared 54-component library
4. Feature flags controlling functionality per brand with rollout percentages
5. Non-technical users modifying UI via the CMS (including a visual screen builder)
6. Server-side data resolution from external sources without client-side changes
7. Overlay support for bottom sheets and modals triggered by component actions
